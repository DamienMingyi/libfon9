<!-- 顯示從 WsSeedVisitor 取得的資料. -->
<!DOCTYPE html>
<html lang="zh-Hant-TW">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <title>fon9seed</title>
 <link rel="stylesheet" href="./fon9.css">
 <script type="text/javascript" src="./utils-seed.js"></script>
<style>
body, .seed, #edPath {
  font-family: Consolas;
}

#topContainer {
  position: relative;
  height: 1.5em;
  clear: both;
  background: #eee;
}
#topLeft {
  position: absolute;
  left: 0px;
  right: calc(1.5em + 1px);
  height: calc(1.5em - 1px);
}
#edPath {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  border: none;
  color: #eee;
  background: #eee;
}
#edPath:focus {
  z-index: 20;
  color: black;
  background: white;
}
#tabsArea {
  position: relative;
  float: left;
  z-index: 10;
}
.tab {
  float: left;
}
.tab label {
  position: relative;
  left: 1px;
  padding: 5px;
  margin-left: -1px;
  border: 1px solid #ccc;
  border-radius: 15px 15px 0 0;
  background: #ddd;
}
.tab label:hover{
  background: #eff;
}
.tab [type=radio] {
  display: none;
}
.tab [type=radio]:checked ~ label {
  background: white;
  border-bottom: 1px solid white;
  z-index: 2;
}
.seed {
  float: left;
  height: 1.5em;
  padding: 0 5px;
  outline: none;
  border: none;
  border-radius: 2px;
  background: #ddd;
}
.seed:hover {
  background: #eff;
  cursor: default;
}
.seed:disabled {
  background: #ddd;
}

#gvArea {
  position: fixed;
  left: 0;
  top: 1.5em;
  bottom: 0;
  width: 100%;
  border-top: 1px solid #ccc;
  overflow: auto;
  cursor: default;
}
.gvTable {
  border-collapse: collapse;
  width: 100%;
  line-height: 1.5em;
  white-space: nowrap;
}
.gvTable thead th {
  position: sticky;
  top: 0;
  background: #eee;
  box-shadow: 0 2px 3px -1px #aaa;
}
.gvTable thead th:first-child {
  z-index: 1;
  left: 0;
}
.gvTable tbody th {
  position: sticky;
  left: 0;
  background: #eee;
  box-shadow: 2px 0 3px -1px #aaa;
}
.gvTable th,
.gvTable td {
  border-right: 1px solid #ccc;
  border-bottom: 1px solid #ccc;
  text-align: left;
}
.gvTable th:last-child,
.gvTable td:last-child {
  border-right: 0;
}
.gvTable tr:nth-child(odd) {
  background: #f9f9f9;
}
.gvTable tr:hover {
  background: #eff;
}
.gvTable tbody th:hover {
  background: #eff;
}
.gvTable td:focus,
.gvTable th:focus {
  outline: none;
  box-shadow: 0 0 2px 1px blue inset;
}
.gvTable [contentEditable="true"]:focus {
  background: #FFFFD3;
  cursor: default;
}
.gvCellUpdating {
  background: #ffe6ea;
}
</style>
</head>
<body>
<div>
 <div id="topContainer">
   <div id="topLeft">
     <div id="tabsArea"></div>
     <input type="text" id="edPath" autocomplete="off" onfocus="this.value=currPath; this.select();" onkeydown="return edPathKeyDown(event)"/>
   </div>
   <div id="topRight">
     <button id="btnReload" type="button" class="seed" style="float:right" onclick="reload();">
     &#8635;</button>
   </div>
 </div>
 <div id="gvArea">
  <table id="gvTable" class="gvTable" onkeydown="return gvTableKeyDown(event)">
   <thead></thead>
   <tbody></tbody>
  </table>
 </div>
</div>

<script>
// public:
/// 當 KeyCell click 時觸發 onKeyCellClick(currPath, key, tabName);
var onKeyCellClick;
/// 當 Tab click 時觸發 onTabChanged(currPath, startkey, tabName);
/// startkey 有可能是 undefined;
var onTabChanged;
/// 當選定新的路徑時觸發 onPathChanged(newPath);
var onPathChanged;
/// 當欄位異動時觸發 onFieldChanged(currPath, key, tabName, fldName, newValue);
var onFieldChanged;

function clearAll() {
  currPath = '';
  currTabIdx = 0;
  gvTable.tHead.innerHTML = '';
  gvTable.tBodies[0].innerHTML = '';
  tabsArea.innerHTML = '';
}
function renderLayout(path, strLayout) {
  if (currPath == path)
    return;
  gvTable.tBodies[0].innerHTML = '';
  currPath = path;
  layout = JSON.parse(strLayout);
  currTabIdx = -1;
  addPathSeeds(path);
  if (layout.tabs.length > 1) {
    let btn = document.createElement('button');
    btn.textContent = '^';
    btn.className = 'seed';
    btn.disabled = true;
    tabsArea.appendChild(btn);
    for (let tab of layout.tabs)
      addTab(++currTabIdx, tab);
  }
  setCurrTabIdx(0);
}
function renderGridView(args, path, gv) {
  if (path != currPath)
    return;
  if (getTabIdx(args) != currTabIdx)
    return;
  let rowsBody = gvTable.tBodies[0];
  rowsBody.innerHTML = '';
  if (gv == '')
    return;
  let rows = gv.split('\n');
  for (let row of rows) {
    let flds = row.split('\x01');
    let rowe = rowsBody.insertRow(-1)
    let cell = rowe.insertCell(-1);
    cell.outerHTML = '<th>' + flds[0] + '</th>';
    cell = rowe.cells[0]; // 因為使用 outerHTML, cell 已經不是 rowe 的 cell, 所以要重新取得.
    cell.tabIndex = 0;
    cell.ondblclick = (ev => keyCellClick(ev.currentTarget));
    for (let i = 1; i < flds.length; ++i) {
      cell = rowe.insertCell(-1);
      cell.textContent = flds[i];
      cell.tabIndex = 0;
      cell.onfocus = gvTableCellFocus;
    }
  }
  setTableFocusCell(1,1);
}
function onRowUpdate(args, path, gv) {
  if (path.substring(0, currPath.length) != currPath)
    return;
  let keytab = parsePath(path.substring(currPath.length));
  if (keytab.length <= 0)
    return;
  keytab = keytab[0];
  if (keytab.tab == '') {
    if (currTabIdx != 0)
      return;
  }
  else if (keytab.tab != layout.tabs[currTabIdx].name)
    return;
  for (let row of gvTable.rows) {
    if (row.cells[0].textContent == keytab.seed) {
      let cells = row.cells;
      let lines = gv.split('\n');
      let flds = lines[0].split('\x01');
      let i = 1;
      for (let fld of flds) {
        let cell;
        if (i < cells.length) {
          cell = cells[i++];
          // 應該要檢查 args = 'fieldName=newValue' 其中的 fieldName.
          // 如果是當初要求的異動, 才移除 gvCellUpdating;
          cell.classList.remove('gvCellUpdating');
        }
        else {
          cell = row.insertCell(-1);
          cell.tabIndex = 0;
          cell.onfocus = gvTableCellFocus;
        }
        cell.textContent = fld;
      }
      break;
    }
  }
}

// private:
let tabsArea = document.getElementById('tabsArea');
let gvArea = document.getElementById('gvArea');
let gvTable = document.getElementById('gvTable');
let layout;
let currTabIdx;
let currPath;

let getTitleOrName = function(n) {
  return (n.title ? n.title : n.name);
}
let addTab = function(tabIdx, tab) {
  let div = document.createElement('div');
  div.className = 'tab';
  let elm = document.createElement('input');
  elm.id = tab.name;
  elm.type = 'radio';
  elm.name = 'tabs';
  elm.index = tabIdx;
  elm.onchange = setCurrTabIdx;
  div.appendChild(elm);
  elm = document.createElement('label');
  elm.htmlFor = tab.name;
  elm.textContent = getTitleOrName(tab);
  div.appendChild(elm);
  tabsArea.appendChild(div);
}
let emitTabChanged = function(startkey) {
  if (onTabChanged) {
    let tab = layout.tabs[currTabIdx];
    onTabChanged(currPath, startkey, (currTabIdx <= 0 ? '' : tab.name));
  }
}
let setCurrTabIdx = function(idx) {
  if (typeof idx !== 'number')
    idx = idx.target.index;
  if (currTabIdx == idx)
    return;
  currTabIdx = idx;
  let rowsBody = gvTable.tBodies[0];
  emitTabChanged((rowsBody.rows.length > 0 ? rowsBody.rows[0].cells[0].textContent : undefined));
  rowsBody.innerHTML = '';
  let tab = layout.tabs[idx];
  let tabEle = document.getElementById(tab.name);
  if (tabEle)
    tabEle.checked = true;
  let strHeader = '<th>' + getTitleOrName(layout.key) + '</th>';
  for (let fld of tab.fields)
    strHeader += '<th>' + getTitleOrName(fld) + '</th>';
  gvTable.tHead.innerHTML = '<tr>' + strHeader + '</tr>';
}

let addPathSeeds = function(path) {
  let nodes = parsePath(path);
  tabsArea.innerHTML = '';
  path = '/';
  for (let i = 0;;) {
    let btn = document.createElement('button');
    btn.textContent = '/';
    btn.className = 'seed';
    btn.type = 'button';
    btn.value = path;
    btn.onclick = function() {
      if (onPathChanged && this.value != currPath)
        onPathChanged(this.value);
    }
    tabsArea.appendChild(btn);
    if (i >= nodes.length)
      break;
    let n = nodes[i++];
    let isLast = (i >= nodes.length);
    btn = document.createElement('button');
    btn.className = 'seed';
    btn.disabled = true;
    let str = n.seed;
    if (n.tab != '')
      str += '^' + n.tab;
    path += str + '/';
    btn.textContent = str;
    tabsArea.appendChild(btn);
    if (isLast)
      break;
  }
}

let getTabIdx = function(args) {
  // args: '[[rowCount],[[key][^tab]]]
  if (args && args.length > 0) {
    let pTab = args.indexOf("^");
    if (pTab >= 0) {
      if (args.substring(pTab+1) == layout.tabs[currTabIdx].name)
        return currTabIdx;
      return -1;
    }
  }
  return 0;
}

let reload = function() {
  emitTabChanged(undefined);
  return false;
}
let edPathKeyDown = function(ev) {
  if (window.event)
    ev = window.event;
  if (ev.keyCode == 27)
    ev.target.blur();
  else if(ev.keyCode == 13) {
    ev.target.blur();
    if (onPathChanged && ev.target.value != currPath)
      onPathChanged(ev.target.value);
  }
  return true;
}

let setTableFocusCell = function(rowIndex, cellIndex) {
  if (rowIndex <= 0) // [0] = header.
    return false;
  if (cellIndex < 0)
    return false;
  let rows = gvTable.rows;
  if (rowIndex >= rows.length)
    return false;
  let row = rows[rowIndex];
  if (cellIndex >= row.cells.length)
    return false;
  // 如果 focus row 往上移動(且有需要捲動),
  // 因為最上面的那行可能被 head row 遮住,
  // 但 scroll bar 可能不認為需要往下捲,
  // 所以這裡必須自己計算, 排除被 head row 遮住的情況.
  let headHeight = rows[0].offsetHeight;
  if (row.offsetTop < gvArea.scrollTop + headHeight)
    gvArea.scrollTop = row.offsetTop - headHeight;
  rows[rowIndex].cells[cellIndex].focus();
  return true;
}

let keyCellClick = function(cell) {
  if (onKeyCellClick)
    onKeyCellClick(currPath, cell.textContent, currTabIdx <= 0 ? '' : layout.tabs[currTabIdx].name);
}
let gvTableKeyDown = function(ev) {
  if (window.event)
    ev = window.event;
  let cell = document.activeElement;
  let rowIndex = cell.parentElement.rowIndex;
  if (!cell.isContentEditable) { // 沒有在 edit mode 才要判斷上下左右鍵,
    if (ev.keyCode == 37) // left
      return !setTableFocusCell(rowIndex, cell.cellIndex - 1);
    if (ev.keyCode == 38) // up
      return !setTableFocusCell(rowIndex - 1, cell.cellIndex);
    if (ev.keyCode == 39) // right
      return !setTableFocusCell(rowIndex, cell.cellIndex + 1);
    if (ev.keyCode == 40) // down
      return !setTableFocusCell(rowIndex + 1, cell.cellIndex);
  }
  if (cell.cellIndex == 0) {
    if (ev.keyCode == 32 || ev.keyCode == 13) { // space or enter key.
      keyCellClick(cell);
      return false;
    }
    return true;
  }
  if (isCellReadonly(cell))
    return true;
  if (ev.keyCode == 27) // esc: 取消(還原資料)編輯.
    cancelCellEdit(cell);
  else if (ev.keyCode == 13) {// enter: 移除內容裡面的 '\n'
    if (cell.isContentEditable)
      confirmCellEdit(cell);
    else
      startCellEdit(cell);
  }
  else if (ev.keyCode == 113) // F2: edit.
    startCellEdit(cell);
  else
    return true;
  return false;
}
let gvTableCellFocus = function(ev) {
  // 進入 focus 之後, 再 double click cell 才進入 edit 模式.
  let cell = ev.currentTarget;
  if (isCellReadonly(cell))
    return;
  cell.onblur = gvTableCellBlur;
  cell.ondblclick = (ev => startCellEdit(ev.target));
}
let gvTableCellBlur = function(ev) {
  let cell = ev.currentTarget;
  if (beforeEditText != undefined && beforeEditText != cell.textContent)
    emitFieldChanged(cell);
  document.execCommand('Unselect');
  cell.removeAttribute('contentEditable');
  cell.ondblclick = undefined;
  cell.onblur = undefined;
  beforeEditText = undefined;
}

let beforeEditText;
// 送出異動訊息, 等收到結果後再更新 cell.textContent
let emitFieldChanged = function(cell) {
  cell.className = 'gvCellUpdating';
  if (onFieldChanged) {
    let tab = layout.tabs[currTabIdx];
    let newValue = cell.textContent.replace(/(?:\r\n|\r|\n)/g, ' ');
    onFieldChanged(currPath,
                   gvTable.rows[cell.parentElement.rowIndex].cells[0].textContent, // keyText
                   currTabIdx <= 0 ? '' : tab.name,
                   tab.fields[cell.cellIndex - 1].name,
                   newValue);
  }
  cell.textContent = beforeEditText;
}
let startCellEdit = function(cell) {
  beforeEditText = cell.textContent;
  cell.ondblclick = undefined;
  cell.contentEditable = true;
  cell.focus();
  // 啟用輸入 & 將輸入游標移動到最後.
  let range = document.createRange();
  range.selectNodeContents(cell);
  range.collapse(false);
  let sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}
let confirmCellEdit = function(cell) {
  if (beforeEditText != cell.textContent)
    emitFieldChanged(cell);
  setExitEditMode(cell);
}
let cancelCellEdit = function(cell) {
  cell.textContent = beforeEditText;
  setExitEditMode(cell);
}
let setExitEditMode = function(cell) {
  cell.blur();
  cell.focus();
}
let isCellReadonly = function(cell) {
  let fldIndex = (cell.cellIndex - 1);
  if (fldIndex < 0)
    return true;
  let fld = layout.tabs[currTabIdx].fields[fldIndex];
  // fld.flags = "x" + "Hex"
  // bit flag: 0x01 = readonly, 0x02 = hide;
  let flags = fld.flags ? parseInt(fld.flags.substring(1), 16) : 0;
  if (flags & 0x01) // readonly?
    return true;
  return false;
}
</script>

</body>
</html>
